/*
Sumo Logic Organizations Management API

Welcome to the Sumo Logic's API Reference for Organizations Management. You can use these APIs to interact with the Sumo Logic platform to manage accounts and subscription. Refer to [API Authentication](https://help.sumologic.com/APIs/General-API-Information/API-Authentication) for more information about authentication. You can also look at [other APIs](https://help.sumologic.com/APIs) for more information about some other API endpoints. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OrganizationsManagementAPIService OrganizationsManagementAPI service
type OrganizationsManagementAPIService service

type ApiCreateAccessKeyRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
	accessKeyCreateRequest *AccessKeyCreateRequest
}

// Deployment on which the calling organization resides.
func (r ApiCreateAccessKeyRequest) ParentDeploymentId(parentDeploymentId string) ApiCreateAccessKeyRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiCreateAccessKeyRequest) AccessKeyCreateRequest(accessKeyCreateRequest AccessKeyCreateRequest) ApiCreateAccessKeyRequest {
	r.accessKeyCreateRequest = &accessKeyCreateRequest
	return r
}

func (r ApiCreateAccessKeyRequest) Execute() (*AccessKey, *http.Response, error) {
	return r.ApiService.CreateAccessKeyExecute(r)
}

/*
CreateAccessKey Create access key for organization.

Get an access ID and key pair for an existing organization based on the organization identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization for which the access ID and key pair is required.
 @return ApiCreateAccessKeyRequest
*/
func (a *OrganizationsManagementAPIService) CreateAccessKey(ctx context.Context, orgId string) ApiCreateAccessKeyRequest {
	return ApiCreateAccessKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return AccessKey
func (a *OrganizationsManagementAPIService) CreateAccessKeyExecute(r ApiCreateAccessKeyRequest) (*AccessKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.CreateAccessKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/{orgId}/accessKey"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}
	if r.accessKeyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("accessKeyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	// body params
	localVarPostBody = r.accessKeyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
	organizationWithSubscriptionDetails *OrganizationWithSubscriptionDetails
}

// Deployment on which the calling organization resides.
func (r ApiCreateOrganizationRequest) ParentDeploymentId(parentDeploymentId string) ApiCreateOrganizationRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

// Details about the organization to create.
func (r ApiCreateOrganizationRequest) OrganizationWithSubscriptionDetails(organizationWithSubscriptionDetails OrganizationWithSubscriptionDetails) ApiCreateOrganizationRequest {
	r.organizationWithSubscriptionDetails = &organizationWithSubscriptionDetails
	return r
}

func (r ApiCreateOrganizationRequest) Execute() (*ReadOrganizationResponse, *http.Response, error) {
	return r.ApiService.CreateOrganizationExecute(r)
}

/*
CreateOrganization Create a new organization.

Create a new child organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrganizationRequest
*/
func (a *OrganizationsManagementAPIService) CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest {
	return ApiCreateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReadOrganizationResponse
func (a *OrganizationsManagementAPIService) CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*ReadOrganizationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadOrganizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.CreateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}
	if r.organizationWithSubscriptionDetails == nil {
		return localVarReturnValue, nil, reportError("organizationWithSubscriptionDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	// body params
	localVarPostBody = r.organizationWithSubscriptionDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrgRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiDeleteOrgRequest) ParentDeploymentId(parentDeploymentId string) ApiDeleteOrgRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiDeleteOrgRequest) Execute() (*ReadOrganizationResponse, *http.Response, error) {
	return r.ApiService.DeleteOrgExecute(r)
}

/*
DeleteOrg Deactivate an organization.

Deactivate an organization with the given identifier, deleting all its data and its subscription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization to deactivate.
 @return ApiDeleteOrgRequest
*/
func (a *OrganizationsManagementAPIService) DeleteOrg(ctx context.Context, orgId string) ApiDeleteOrgRequest {
	return ApiDeleteOrgRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ReadOrganizationResponse
func (a *OrganizationsManagementAPIService) DeleteOrgExecute(r ApiDeleteOrgRequest) (*ReadOrganizationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadOrganizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.DeleteOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/{orgId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDelinkOrgRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
	delinkChildOrgsRequest *DelinkChildOrgsRequest
}

// Deployment on which the calling organization resides.
func (r ApiDelinkOrgRequest) ParentDeploymentId(parentDeploymentId string) ApiDelinkOrgRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

// Identifier of organizations to delink.
func (r ApiDelinkOrgRequest) DelinkChildOrgsRequest(delinkChildOrgsRequest DelinkChildOrgsRequest) ApiDelinkOrgRequest {
	r.delinkChildOrgsRequest = &delinkChildOrgsRequest
	return r
}

func (r ApiDelinkOrgRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DelinkOrgExecute(r)
}

/*
DelinkOrg Delink a child Org.

Delink a child Org from Parent Org if it is deactivated already.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDelinkOrgRequest
*/
func (a *OrganizationsManagementAPIService) DelinkOrg(ctx context.Context) ApiDelinkOrgRequest {
	return ApiDelinkOrgRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *OrganizationsManagementAPIService) DelinkOrgExecute(r ApiDelinkOrgRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.DelinkOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/delink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}
	if r.delinkChildOrgsRequest == nil {
		return localVarReturnValue, nil, reportError("delinkChildOrgsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	// body params
	localVarPostBody = r.delinkChildOrgsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllocatedCreditsRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetAllocatedCreditsRequest) ParentDeploymentId(parentDeploymentId string) ApiGetAllocatedCreditsRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetAllocatedCreditsRequest) Execute() (*AllocatedCredits, *http.Response, error) {
	return r.ApiService.GetAllocatedCreditsExecute(r)
}

/*
GetAllocatedCredits Get allocated credits.

Returns the total allocated credits of all non free and trial child orgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllocatedCreditsRequest
*/
func (a *OrganizationsManagementAPIService) GetAllocatedCredits(ctx context.Context) ApiGetAllocatedCreditsRequest {
	return ApiGetAllocatedCreditsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllocatedCredits
func (a *OrganizationsManagementAPIService) GetAllocatedCreditsExecute(r ApiGetAllocatedCreditsRequest) (*AllocatedCredits, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllocatedCredits
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetAllocatedCredits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/allocatedCredits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentsRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetDeploymentsRequest) ParentDeploymentId(parentDeploymentId string) ApiGetDeploymentsRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetDeploymentsRequest) Execute() ([]Deployment, *http.Response, error) {
	return r.ApiService.GetDeploymentsExecute(r)
}

/*
GetDeployments List available deployments.

Get deployment details where organization can be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeploymentsRequest
*/
func (a *OrganizationsManagementAPIService) GetDeployments(ctx context.Context) ApiGetDeploymentsRequest {
	return ApiGetDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Deployment
func (a *OrganizationsManagementAPIService) GetDeploymentsExecute(r ApiGetDeploymentsRequest) ([]Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrgUsageRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetOrgUsageRequest) ParentDeploymentId(parentDeploymentId string) ApiGetOrgUsageRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetOrgUsageRequest) Execute() (*DetailedUsage, *http.Response, error) {
	return r.ApiService.GetOrgUsageExecute(r)
}

/*
GetOrgUsage Get detailed usage of an organization.

Get the detailed usage breakdown of an existing organization based on the organization identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization for which the details are required.
 @return ApiGetOrgUsageRequest
*/
func (a *OrganizationsManagementAPIService) GetOrgUsage(ctx context.Context, orgId string) ApiGetOrgUsageRequest {
	return ApiGetOrgUsageRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return DetailedUsage
func (a *OrganizationsManagementAPIService) GetOrgUsageExecute(r ApiGetOrgUsageRequest) (*DetailedUsage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetOrgUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/usages/{orgId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetOrganizationRequest) ParentDeploymentId(parentDeploymentId string) ApiGetOrganizationRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetOrganizationRequest) Execute() (*ReadOrganizationResponse, *http.Response, error) {
	return r.ApiService.GetOrganizationExecute(r)
}

/*
GetOrganization Get an organization's details.

Get details of an existing organization based on an organization identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization for which the details are required.
 @return ApiGetOrganizationRequest
*/
func (a *OrganizationsManagementAPIService) GetOrganization(ctx context.Context, orgId string) ApiGetOrganizationRequest {
	return ApiGetOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ReadOrganizationResponse
func (a *OrganizationsManagementAPIService) GetOrganizationExecute(r ApiGetOrganizationRequest) (*ReadOrganizationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadOrganizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/{orgId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParentOrgDetailsRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetParentOrgDetailsRequest) ParentDeploymentId(parentDeploymentId string) ApiGetParentOrgDetailsRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetParentOrgDetailsRequest) Execute() (*ParentUsage, *http.Response, error) {
	return r.ApiService.GetParentOrgDetailsExecute(r)
}

/*
GetParentOrgDetails Get usage details.

Get the credits usage and allocation details of the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetParentOrgDetailsRequest
*/
func (a *OrganizationsManagementAPIService) GetParentOrgDetails(ctx context.Context) ApiGetParentOrgDetailsRequest {
	return ApiGetParentOrgDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ParentUsage
func (a *OrganizationsManagementAPIService) GetParentOrgDetailsExecute(r ApiGetParentOrgDetailsRequest) (*ParentUsage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParentUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetParentOrgDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/usages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParentOrgInfoRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetParentOrgInfoRequest) ParentDeploymentId(parentDeploymentId string) ApiGetParentOrgInfoRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetParentOrgInfoRequest) Execute() (*ParentOrgInfo, *http.Response, error) {
	return r.ApiService.GetParentOrgInfoExecute(r)
}

/*
GetParentOrgInfo Get parent organization information.

Get information about parent organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetParentOrgInfoRequest
*/
func (a *OrganizationsManagementAPIService) GetParentOrgInfo(ctx context.Context) ApiGetParentOrgInfoRequest {
	return ApiGetParentOrgInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ParentOrgInfo
func (a *OrganizationsManagementAPIService) GetParentOrgInfoExecute(r ApiGetParentOrgInfoRequest) (*ParentOrgInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParentOrgInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetParentOrgInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/parentOrg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProvisioningRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetProvisioningRequest) ParentDeploymentId(parentDeploymentId string) ApiGetProvisioningRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetProvisioningRequest) Execute() (*Provisioning, *http.Response, error) {
	return r.ApiService.GetProvisioningExecute(r)
}

/*
GetProvisioning Get provisioning status for a child organization.

Get provisioning status for a child organization..

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization for which the details are required.
 @return ApiGetProvisioningRequest
*/
func (a *OrganizationsManagementAPIService) GetProvisioning(ctx context.Context, orgId string) ApiGetProvisioningRequest {
	return ApiGetProvisioningRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return Provisioning
func (a *OrganizationsManagementAPIService) GetProvisioningExecute(r ApiGetProvisioningRequest) (*Provisioning, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provisioning
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetProvisioning")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/provisioning/{orgId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubdomainLoginUrlRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
}

// Deployment on which the calling organization resides.
func (r ApiGetSubdomainLoginUrlRequest) ParentDeploymentId(parentDeploymentId string) ApiGetSubdomainLoginUrlRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

func (r ApiGetSubdomainLoginUrlRequest) Execute() (*Subdomain, *http.Response, error) {
	return r.ApiService.GetSubdomainLoginUrlExecute(r)
}

/*
GetSubdomainLoginUrl Get an organization's subdomain login URL.

Get the login URL for the subdomain configured organization based on the organization identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the child organization for which the loginUrl is required.
 @return ApiGetSubdomainLoginUrlRequest
*/
func (a *OrganizationsManagementAPIService) GetSubdomainLoginUrl(ctx context.Context, orgId string) ApiGetSubdomainLoginUrlRequest {
	return ApiGetSubdomainLoginUrlRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return Subdomain
func (a *OrganizationsManagementAPIService) GetSubdomainLoginUrlExecute(r ApiGetSubdomainLoginUrlRequest) (*Subdomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subdomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetSubdomainLoginUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/{orgId}/subdomainLoginUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsagesRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
	requestBody *[]string
	limit *int32
	token *string
}

// Deployment on which the calling organization resides.
func (r ApiGetUsagesRequest) ParentDeploymentId(parentDeploymentId string) ApiGetUsagesRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

// List of the organizations for which usage needs to be fetched.
func (r ApiGetUsagesRequest) RequestBody(requestBody []string) ApiGetUsagesRequest {
	r.requestBody = &requestBody
	return r
}

// Limit the number of results returned in the response. The number of results returned may be less than the &#x60;limit&#x60;.
func (r ApiGetUsagesRequest) Limit(limit int32) ApiGetUsagesRequest {
	r.limit = &limit
	return r
}

// Continuation token to get the next page of results. A page object with the next continuation token is returned in the response body. Subsequent GET requests should specify the continuation token to get the next page of results. &#x60;token&#x60; is set to null when no more pages are left.
func (r ApiGetUsagesRequest) Token(token string) ApiGetUsagesRequest {
	r.token = &token
	return r
}

func (r ApiGetUsagesRequest) Execute() (*ListUsagesResponse, *http.Response, error) {
	return r.ApiService.GetUsagesExecute(r)
}

/*
GetUsages Get credits usages for a list of organizations.

Get the credits usage details of all the given organizations. The response is paginated with a default limit of 100 organizations per page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsagesRequest
*/
func (a *OrganizationsManagementAPIService) GetUsages(ctx context.Context) ApiGetUsagesRequest {
	return ApiGetUsagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListUsagesResponse
func (a *OrganizationsManagementAPIService) GetUsagesExecute(r ApiGetUsagesRequest) (*ListUsagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.GetUsages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/usages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 1000 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 1000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrganizationsRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	parentDeploymentId *string
	limit *int32
	token *string
	status *string
}

// Deployment on which the calling organization resides.
func (r ApiListOrganizationsRequest) ParentDeploymentId(parentDeploymentId string) ApiListOrganizationsRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

// Limit the number of organizations returned in the response. The number of organizations returned may be less than the &#x60;limit&#x60;.
func (r ApiListOrganizationsRequest) Limit(limit int32) ApiListOrganizationsRequest {
	r.limit = &limit
	return r
}

// Continuation token to get the next page of results. A page object with the next continuation token is returned in the response body. Subsequent GET requests should specify the continuation token to get the next page of results. &#x60;token&#x60; is set to null when no more pages are left.
func (r ApiListOrganizationsRequest) Token(token string) ApiListOrganizationsRequest {
	r.token = &token
	return r
}

// Status of an organization, based on its subscription. Valid values are &#39;Active&#39;, &#39;Inactive&#39;, and &#39;All&#39;. By default, only active organizations are listed.
func (r ApiListOrganizationsRequest) Status(status string) ApiListOrganizationsRequest {
	r.status = &status
	return r
}

func (r ApiListOrganizationsRequest) Execute() (*ListOrganizationResponse, *http.Response, error) {
	return r.ApiService.ListOrganizationsExecute(r)
}

/*
ListOrganizations Get a list of organizations.

Get a list of all organizations in this account. The response is paginated with a default limit of 100 organizations per page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrganizationsRequest
*/
func (a *OrganizationsManagementAPIService) ListOrganizations(ctx context.Context) ApiListOrganizationsRequest {
	return ApiListOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOrganizationResponse
func (a *OrganizationsManagementAPIService) ListOrganizationsExecute(r ApiListOrganizationsRequest) (*ListOrganizationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrganizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.ListOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "Active"
		r.status = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionRequest struct {
	ctx context.Context
	ApiService *OrganizationsManagementAPIService
	orgId string
	parentDeploymentId *string
	baselines *Baselines
}

// Deployment on which the calling organization resides.
func (r ApiUpdateSubscriptionRequest) ParentDeploymentId(parentDeploymentId string) ApiUpdateSubscriptionRequest {
	r.parentDeploymentId = &parentDeploymentId
	return r
}

// The utilization baselines for the organization and the updated credits allocation. For organizations on Trial/Free plans, reallocating credits will upgrade their plan type to your plan. The plan change cannot be rolled back.
func (r ApiUpdateSubscriptionRequest) Baselines(baselines Baselines) ApiUpdateSubscriptionRequest {
	r.baselines = &baselines
	return r
}

func (r ApiUpdateSubscriptionRequest) Execute() (*ReadOrganizationResponse, *http.Response, error) {
	return r.ApiService.UpdateSubscriptionExecute(r)
}

/*
UpdateSubscription Update an organization.

Update an existing organization's subscription based on its identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Identifier of the organization to update.
 @return ApiUpdateSubscriptionRequest
*/
func (a *OrganizationsManagementAPIService) UpdateSubscription(ctx context.Context, orgId string) ApiUpdateSubscriptionRequest {
	return ApiUpdateSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ReadOrganizationResponse
func (a *OrganizationsManagementAPIService) UpdateSubscriptionExecute(r ApiUpdateSubscriptionRequest) (*ReadOrganizationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadOrganizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsManagementAPIService.UpdateSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/organizations/{orgId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 19 {
		return localVarReturnValue, nil, reportError("orgId must have at least 19 elements")
	}
	if strlen(r.orgId) > 23 {
		return localVarReturnValue, nil, reportError("orgId must have less than 23 elements")
	}
	if r.parentDeploymentId == nil {
		return localVarReturnValue, nil, reportError("parentDeploymentId is required and must be specified")
	}
	if r.baselines == nil {
		return localVarReturnValue, nil, reportError("baselines is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "parentDeploymentId", r.parentDeploymentId, "simple", "")
	// body params
	localVarPostBody = r.baselines
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
