/*
Sumo Logic Organizations Management API

Welcome to the Sumo Logic's API Reference for Organizations Management. You can use these APIs to interact with the Sumo Logic platform to manage accounts and subscription. Refer to [API Authentication](https://help.sumologic.com/APIs/General-API-Information/API-Authentication) for more information about authentication. You can also look at [other APIs](https://help.sumologic.com/APIs) for more information about some other API endpoints. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the UsagePerProductVariable type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &UsagePerProductVariable{}

// UsagePerProductVariable struct for UsagePerProductVariable
type UsagePerProductVariable struct {
	// A Product Variable is a unique service performance feature that is tracked through credit utilization. Valid values are 'continuousIngest', 'frequentIngest', 'storage', 'metrics', 'infrequentScan', 'infrequentIngest', 'inFrequentStorage', 'cseIngest', 'cseStorage'.
	ProductVariable string `json:"productVariable"`
	// Denotes the total number of actual credits that have been used.
	CreditsUsed float64 `json:"creditsUsed"`
	// Denotes the total number of credits that have been used in form of deployment charges.
	DeploymentChargeCredits float64 `json:"deploymentChargeCredits"`
	// Denotes the total number of credits that have been used including deployment charges.
	CreditsDeducted float64 `json:"creditsDeducted"`
	// The native utilization of the product variable.
	Utilization float64 `json:"utilization"`
	// The unit in which the native utilization is measured.
	Unit string `json:"unit" validate:"regexp=^(GB|DPM)$"`
}

type _UsagePerProductVariable UsagePerProductVariable

// NewUsagePerProductVariable instantiates a new UsagePerProductVariable object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUsagePerProductVariable(productVariable string, creditsUsed float64, deploymentChargeCredits float64, creditsDeducted float64, utilization float64, unit string) *UsagePerProductVariable {
	this := UsagePerProductVariable{}
	this.ProductVariable = productVariable
	this.CreditsUsed = creditsUsed
	this.DeploymentChargeCredits = deploymentChargeCredits
	this.CreditsDeducted = creditsDeducted
	this.Utilization = utilization
	this.Unit = unit
	return &this
}

// NewUsagePerProductVariableWithDefaults instantiates a new UsagePerProductVariable object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUsagePerProductVariableWithDefaults() *UsagePerProductVariable {
	this := UsagePerProductVariable{}
	return &this
}

// GetProductVariable returns the ProductVariable field value
func (o *UsagePerProductVariable) GetProductVariable() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ProductVariable
}

// GetProductVariableOk returns a tuple with the ProductVariable field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetProductVariableOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ProductVariable, true
}

// SetProductVariable sets field value
func (o *UsagePerProductVariable) SetProductVariable(v string) {
	o.ProductVariable = v
}

// GetCreditsUsed returns the CreditsUsed field value
func (o *UsagePerProductVariable) GetCreditsUsed() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.CreditsUsed
}

// GetCreditsUsedOk returns a tuple with the CreditsUsed field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetCreditsUsedOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CreditsUsed, true
}

// SetCreditsUsed sets field value
func (o *UsagePerProductVariable) SetCreditsUsed(v float64) {
	o.CreditsUsed = v
}

// GetDeploymentChargeCredits returns the DeploymentChargeCredits field value
func (o *UsagePerProductVariable) GetDeploymentChargeCredits() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.DeploymentChargeCredits
}

// GetDeploymentChargeCreditsOk returns a tuple with the DeploymentChargeCredits field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetDeploymentChargeCreditsOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.DeploymentChargeCredits, true
}

// SetDeploymentChargeCredits sets field value
func (o *UsagePerProductVariable) SetDeploymentChargeCredits(v float64) {
	o.DeploymentChargeCredits = v
}

// GetCreditsDeducted returns the CreditsDeducted field value
func (o *UsagePerProductVariable) GetCreditsDeducted() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.CreditsDeducted
}

// GetCreditsDeductedOk returns a tuple with the CreditsDeducted field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetCreditsDeductedOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CreditsDeducted, true
}

// SetCreditsDeducted sets field value
func (o *UsagePerProductVariable) SetCreditsDeducted(v float64) {
	o.CreditsDeducted = v
}

// GetUtilization returns the Utilization field value
func (o *UsagePerProductVariable) GetUtilization() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.Utilization
}

// GetUtilizationOk returns a tuple with the Utilization field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetUtilizationOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Utilization, true
}

// SetUtilization sets field value
func (o *UsagePerProductVariable) SetUtilization(v float64) {
	o.Utilization = v
}

// GetUnit returns the Unit field value
func (o *UsagePerProductVariable) GetUnit() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Unit
}

// GetUnitOk returns a tuple with the Unit field value
// and a boolean to check if the value has been set.
func (o *UsagePerProductVariable) GetUnitOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Unit, true
}

// SetUnit sets field value
func (o *UsagePerProductVariable) SetUnit(v string) {
	o.Unit = v
}

func (o UsagePerProductVariable) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o UsagePerProductVariable) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["productVariable"] = o.ProductVariable
	toSerialize["creditsUsed"] = o.CreditsUsed
	toSerialize["deploymentChargeCredits"] = o.DeploymentChargeCredits
	toSerialize["creditsDeducted"] = o.CreditsDeducted
	toSerialize["utilization"] = o.Utilization
	toSerialize["unit"] = o.Unit
	return toSerialize, nil
}

func (o *UsagePerProductVariable) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"productVariable",
		"creditsUsed",
		"deploymentChargeCredits",
		"creditsDeducted",
		"utilization",
		"unit",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varUsagePerProductVariable := _UsagePerProductVariable{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varUsagePerProductVariable)

	if err != nil {
		return err
	}

	*o = UsagePerProductVariable(varUsagePerProductVariable)

	return err
}

type NullableUsagePerProductVariable struct {
	value *UsagePerProductVariable
	isSet bool
}

func (v NullableUsagePerProductVariable) Get() *UsagePerProductVariable {
	return v.value
}

func (v *NullableUsagePerProductVariable) Set(val *UsagePerProductVariable) {
	v.value = val
	v.isSet = true
}

func (v NullableUsagePerProductVariable) IsSet() bool {
	return v.isSet
}

func (v *NullableUsagePerProductVariable) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUsagePerProductVariable(val *UsagePerProductVariable) *NullableUsagePerProductVariable {
	return &NullableUsagePerProductVariable{value: val, isSet: true}
}

func (v NullableUsagePerProductVariable) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUsagePerProductVariable) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


